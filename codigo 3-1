// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract EcoBuildingToken is ERC20, Ownable {
using Counters for Counters.Counter;
Counters.Counter private _tokenIdCounter;

// Governance proposal structure
struct Proposal {
string description;
uint256 voteCount;
mapping(address => bool) voters;
bool executed;
}

// Mapping of proposals
mapping(uint256 => Proposal) public proposals;

// NFT contract for buildings
contract BuildingNFT is ERC721 {
using Counters for Counters.Counter;
Counters.Counter private _nftIdCounter;

constructor() ERC721("BuildingNFT", "BNFT") {}

function mintNFT(address to) public returns (uint256) {
_nftIdCounter.increment();
uint256 newNftId = _nftIdCounter.current();
_mint(to, newNftId);
return newNftId;
}
}

BuildingNFT public buildingNFT;

constructor() ERC20("EcoBuildingToken", "EBT") {
buildingNFT = new BuildingNFT();
}

// Function to create a new proposal
function createProposal(string memory description) public onlyOwner {
Proposal storage newProposal = proposals[_tokenIdCounter.current()];
newProposal.description = description;
newProposal.voteCount = 0;
newProposal.executed = false;
_tokenIdCounter.increment();
}

// Function to vote on a proposal
function voteOnProposal(uint256 proposalId) public {
Proposal storage proposal = proposals[proposalId];
require(!proposal.voters[msg.sender], "You have already voted.");
proposal.voters[msg.sender] = true;
proposal.voteCount++;
}

// Function to mint tokens for the project
function
